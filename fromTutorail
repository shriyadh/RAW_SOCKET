#!/usr/bin/env python3
# TOKEN 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
# My password Benzene66
# Sequence Number (raw): 300800002
# to compare files use: cmp 2MB.log 2MB-MINE.log
# or compare checksums with md5sum filename.log


import ssl
import socket
import sys
from random import randint
from struct import *
from urllib.parse import urlparse
from TCP import TCP

# # print("UNPACKING TCP%%%%%%%%%%%%%%%%%%%%%")
# # print(recv_segment)
# tcp_header = struct.unpack('!HHLLBBH', recv_segment[0:16])
# # print("LMAOOOOOO")
# self.client_ip = client
# self.server_ip = server
# self.client_port = tcp_header[0]
# self.server_port = tcp_header[1]
# self.seq_num = tcp_header[2]
# self.ack_num = tcp_header[3]
# offset = tcp_header[4]
# self.offset = (offset >> 4) * 4  # giving 24 for first syn/ack response because the header has an options field
# flags = tcp_header[5]
# self.wnd_size = tcp_header[6]
# self.checksum = struct.unpack('H', recv_segment[16:18])
# self.urg = struct.unpack('!H', recv_segment[18:20])
# self.data = recv_segment[self.offset:]  ## changed the data segment
# # ("LMAOOOOOO")
#
# # flags in segment
# self.fin = flags & 0x01
# self.syn = (flags & 0x02) >> 1
# self.rst = (flags & 0x04) >> 2
# self.psh = (flags & 0x08) >> 3
# self.ack = (flags & 0x10) >> 4
# self.urg = (flags & 0x20) >> 5
#
# # pseudo header fields from IP header -- should have source IP, Destination IP, Protocol field
# # TCP length, TCP header ===== needed for calculating checksum accurately
# # tcp_len = len(self.data) + (offset * 4)
# # tcp len is just size of entire segment, the above code does make sense but offset * 4 is giving 24 ???
# tcp_len = len(recv_segment)
#
# pseudo_header = struct.pack('!4s4sBBH',
#                             socket.inet_aton(self.client_ip),
#                             socket.inet_aton(self.server_ip),
#                             0, socket.IPPROTO_TCP, tcp_len)
#
# to_check = pseudo_header + recv_segment
#
# if calculate_checksum(to_check) != 0:
#     print("Error in Checksum")
#     pass
#     # raise error
# else:
#     print("no error in unpacking")
#     print("******** received checksum", hex(calculate_checksum(to_check)))
#     return to_check
#
#
# # # --------------  CREATE METHOD TO SET FIELDS FOR THE TCP PACKET TO SEND
#

class RawSocket():

    receiver_socket = None

    sender_socket = None

    remote_host = ""
    local_host  = ""
    remote_port = -9999
    local_port = -9999
    def __init__(self):
        self.sender_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
        self.receiver_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
        self.local_port = randint(1001, 65535)

        self.local_IPAddress = ip


    def connect(self, host, port):

        self.remote_host = host
        self.remote_port = 80
        self.tcp_seq = 0


def parse_cmd_line():
    try:
        url = sys.argv[1]
    except:
        sys.exit("Please provide proper URL")

    return url


def get_file_name(url):
    # check if proper path is given, if not set default
    if url.endswith('/'):
        file = "index.html"
    else:
        # split to get file name
        file = url.split('/')[-1]

    return file


def make_request(url):
    return "GET " + url + " HTTP/1.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\r\n" \
                          "Connection: close\r\n\r\n"


def start_download(url):
    # parse file name
    file = get_file_name(url)
    print(file)

    # get host and path
    eg = "https://david.choffnes.com/classes/cs5700f22/2MB.log"
    urlInformation = urlparse(url)
    print(urlInformation)

    host_name = urlInformation.netloc
    filePath = urlInformation.path
    print(filePath)

    # make request
    get_request = make_request(url)
    print(get_request)

    # add TCP header + IP header to create IP Datagram
    #sock = TCP()
    #sock.establish_handshake(host_name, 80)
    #sock.send_request(get_request)



    # open file and read
    # fOpen = open(file, 'wb+')

    # create socket
    # create_socket()


def main():
    # testing
    # parse the cmd line to get the url download link
    #url = parse_cmd_line()
   # print(url)


    #start_download(url)
    test = TCP()
    test.establish_handshake("david.choffnes.com", 80)





if __name__ == "__main__":
    main()